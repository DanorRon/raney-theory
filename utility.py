import math
import numpy as np
import pyvista as pv
from numpy import random
import itertools

def to_base(number, base):
    """Converts a non-negative number to a string of digits in the given base.
    base must be >= 2 and <= 10 and the first digit in the string of digits is the most significant one.
    """
    if not number:
        return "0"

    digits = []
    while number:
        digits.append(number % base)
        number //= base
    output_list = list(reversed(digits))
    output_str = ''.join(map(str, output_list))
    return output_str

#Finds next isotone profile vector
#Inefficient and doesn't best make use of the algorithm
def next_profile(x):
    """
    Computes the next vector in the profile sequence for the vector x
    """
    new_x = x.copy()
    new_x.sort()
    for i in range(len(new_x)-1, 0, -1):
        new_x[i] = new_x[i] - new_x[i-1]
    return sorted(new_x)

def central_sum(x):
    """
    Computes t(x), the central sum of the vector x
    """
    x_copy = x.copy()
    x_copy.sort()
    sum = x_copy[-1]
    for i in range(1000):
        x_copy = next_profile(x_copy)
        sum = sum + x_copy[-1]
    return sum

#TODO test
def is_central(x):
    """
    Returns True if x is central and False is x is peripheral
    """
    comparison_const = 100
    sum = central_sum(x)
    if sum < comparison_const*max(x): # Returns peripheral if the central sum is much greater than the maximum coordinate of x
        return True
    else:
        return False

def minimal_top(x):
    """
    Returns the minimal topping of the vector x
    The returned vector has dimension 1 greater than the dimension of x
    """
    sum = central_sum(x)
    x.append(sum)
    return x

def generate_limcone(perms, repeating=False, iters=100):
    """
    Finds the corner rays of the limcone generated by the given permutation sequence
    Can be used to find some vector that accepts the given permutation sequence
    Example format of perms: (each permutation is written as the second row in 2-row notation)
        perms = [[0,1,2],
                 [1,0,2]]
    Returns a matrix with columns equal to the corner rays
    """
    dim = len(perms[0])
    matrix = np.identity(dim)
    for perm in perms:
        M_p = summation_matrix(perm)
        matrix = matrix @ M_p

    if repeating == False:
        return matrix
    else:
        iterated_matrix = np.linalg.matrix_power(matrix, iters)
        return iterated_matrix

def normalize_vec(raw):
    """
    Normalize a vector so that it lies on the fundamental simplex
    """
    norm = [float(i)/sum(raw) for i in raw]
    return norm

def normalize_columns(matrix):
    """
    Normalize the columns of a square matrix independently from each other so each column vector lies on the fundamental simplex
    """
    dim = len(matrix)
    transposed = np.transpose(matrix)
    new_matrix = np.empty((dim, dim))
    for i in range(dim):
        sum = np.sum(transposed[i])
        for j in range(dim):
            new_matrix[i][j] = transposed[i][j]/sum
    return np.transpose(new_matrix)

def permutation_matrix(perm):
    """
    Return a permutation matrix given a permutation written as the second row in 2-row notation
    """
    dim = len(perm)
    matrix = np.zeros((dim, dim))
    for i in range(dim):
        for j in range(dim):
            if j == perm[i]:
                matrix[i][j] = 1
    return matrix

def summation_matrix(perm):
    """
    Returns the summation matrix M_p given the permutation perm
    """
    dim = len(perm)
    A = np.zeros((dim, dim))
    for i in range(dim):
        for j in range(dim):
            if i >= j:
                A[i][j] = 1
    B_p = permutation_matrix(perm)
    M_p = np.linalg.inv(B_p) @ A @ B_p
    return M_p

def find_perm_seq(x):
    """
    Given any vector, finds the permutation sequence that it accepts
    Since floating point arithmetic is limited, this function returns undefined output once the number of perms reaches the depth of the given vector
       - Then the vector will accept the corresponding ultimately constant permutation sequence
    """
    x_k_list = [x] #x is x_0
    perms = []
    for i in range(100):
        #At start: Current x_k is the last item in x_k_list and P_k is the last item in perms
        perms.append(isotone_perm(x_k_list[-1])) #append P_k+1
        x_k_list.append(next_xk(x_k_list[-1])) #append x_k+1
    perms_array = np.vstack(perms)
    return perms_array

def isotone_perm(x):
    """
    Finds the permutation that when applied to x, makes x isotone (where applying is the operation x -> xP)
    Requires x to be nonnegative
    Equivalent to finding P_k+1 given x_k
    """
    x_copy = x.copy()
    perm = np.zeros((len(x)))
    for i in range(len(x)): #repeats len(x) times
        max = np.argmax(x_copy)
        perm[len(x) - i - 1] = max
        x_copy[max] = -1 # sets to value out of domain
        #print(str(max) + "  " + str(x) + "  " + str(perm))
    return perm
    

def is_isotone(x):
    """
    Returns True if x is isotone and False if not
    """
    prev = 0
    for curr in range(1, len(x)):
        if x[curr] < x[prev]:
            return False
        else:
            prev = curr
    return True

#TODO check if this works properly
def permute(x, perm):
    """
    Returns xP, the result of applying perm to x
    """
    new_x = np.zeros((len(x)))
    for i in range(len(x)):
        new_x[i] = x[perm[i]]
    return new_x

def next_xk(xk):
    """
    Returns x_k+1 given x_k
    Uses the matrix ideas in the proof of Proposition 2.8
    """
    P_k1 = isotone_perm(xk) #P_k+1
    M_P_k1 = summation_matrix(P_k1) # M(P_k+1)
    #x_k = M(P_k+1) @ x_k+1
    x_k1 = np.linalg.inv(M_P_k1) @ xk
    #print(str(M_P_k1) + "  " + str(x_k1))
    return x_k1

#This function is a bit weird bc floating-point arithmetic determines how accurately we can find the depth
#def depth(x)

def angle():
    #get angle of vector/limcone/cone

def ang_diam():
    #get angular diameter of vector/limcone/cone


def initialize_plotter_3D(shape):
    """
    """

    pl = pv.Plotter(shape=shape)

    for i in range(shape[0]):
        for j in range(shape[1]):
            pl.subplot(i,j)
            pl.show_bounds(bounds=[-5,5,-5,5,-5,5], location='all')
            #pl.add_mesh(pv.Line((0,0,0), (0,0,5)), line_width=3, color='black')
            #pl.add_mesh(pv.Line((0,0,0), (0,5,0)), line_width=3, color='black')
            #pl.add_mesh(pv.Line((0,0,0), (5,0,0)), line_width=3, color='black')
            triangle = pv.UnstructuredGrid([3, *list(range(3))], [pv.CellType.TRIANGLE], [[1,0,0], [0,1,0], [0,0,1]])
            pl.add_mesh(triangle)
            pl.camera.position = (5,5,5)
            #pl.camera.SetParallelProjection(True)

    return pl

def initialize_plotter_4D(shape):
    """
    """
    
    pl = pv.Plotter(shape=shape)

    for i in range(shape[0]):
        for j in range(shape[1]):
            pl.subplot(i,j)
            pl.show_bounds(bounds=[-5,5,-5,5,-5,5], location='all')
            #pl.add_mesh(pv.Line((0,0,0), (0,0,5)), line_width=3, color='black')
            #pl.add_mesh(pv.Line((0,0,0), (0,5,0)), line_width=3, color='black')
            #pl.add_mesh(pv.Line((0,0,0), (5,0,0)), line_width=3, color='black')
            #tetrahedron = pv.UnstructuredGrid([4, *list(range(4))], [pv.CellType.BEZIER_TETRAHEDRON], [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]]) #TODO
            #pl.add_mesh(tetrahedron)
            pl.camera.position = (5,5,5)
            #pl.camera.SetParallelProjection(True)

    return pl