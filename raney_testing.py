import math
import numpy as np
import pyvista as pv
from numpy import random
import itertools

def to_base(number, base):
    """Converts a non-negative number to a string of digits in the given base.

    The base must be an integer greater than or equal to 2 and the first digit
    in the list of digits is the most significant one.
    """
    if not number:
        return "0"

    digits = []
    while number:
        digits.append(number % base)
        number //= base
    output_list = list(reversed(digits))
    output_str = ''.join(map(str, output_list))
    return output_str

vec = [1, (1+math.sqrt(5))/2, ((1+math.sqrt(5))/2)**3]

#Finds next isotone profile vector
#Inefficient and doesn't best make use of the algorithm
def next_profile(x):
    new_x = x.copy()
    new_x.sort()
    for i in range(len(new_x)-1, 0, -1):
        new_x[i] = new_x[i] - new_x[i-1]
    return sorted(new_x)

def central_sum(x):
    x_copy = x.copy()
    x_copy.sort()
    sum = x_copy[-1]
    for i in range(1000):
        x_copy = next_profile(x_copy)
        sum = sum + x_copy[-1]
    return sum

def is_central(x):
    sum = central_sum(x)
    if sum < 100: #TODO Should change to comparing ratios between elements
        return True
    else:
        return False

def minimal_top(x):
    sum = central_sum(x)
    x.append(sum)
    return x

#Finds the corner rays of the limcone generated by the given permutation sequence
#Can be used to find some vector that accepts the given permutation sequence
#Example format of perms: (each permutation is written as the second row in 2-row notation)
    #perms = [[0,1,2],
    #         [1,0,2]]
#Returns a matrix with columns equal to the corner rays
def generate_limcone(perms, repeating=False, iters=100):
    dim = len(perms[0])
    matrix = np.identity(dim)
    for perm in perms:
        M_p = summation_matrix(perm)
        matrix = matrix @ M_p

    if repeating == False:
        return matrix
    else:
        iterated_matrix = np.linalg.matrix_power(matrix, iters)
        return iterated_matrix

#Normalize the columns of a square matrix independently from each other so each column vector is on the fundamental simplex
def normalize_columns(matrix):
    dim = len(matrix)
    transposed = np.transpose(matrix)
    new_matrix = np.empty((dim, dim))
    for i in range(dim):
        sum = np.sum(transposed[i])
        for j in range(dim):
            new_matrix[i][j] = transposed[i][j]/sum
    return np.transpose(new_matrix)

#Return a permutation matrix given a permutation written as the second row in 2-row notation
def permutation_matrix(perm):
    dim = len(perm)
    matrix = np.zeros((dim, dim))
    for i in range(dim):
        for j in range(dim):
            if j == perm[i]:
                matrix[i][j] = 1
    return matrix

#Returns a summation matrix given a permutation
def summation_matrix(perm):
    dim = len(perm)
    A = np.zeros((dim, dim))
    for i in range(dim):
        for j in range(dim):
            if i >= j:
                A[i][j] = 1
    B_p = permutation_matrix(perm)
    M_p = np.linalg.inv(B_p) @ A @ B_p
    return M_p


#Given any vector, finds the permutation sequence that it accepts
#Since floating point arithmetic is limited, this function terminates once the number of perms reaches the depth of the given vector
#   - Then the vector will accept the given ultimately constant permutation sequence
def find_perm_seq(x):
    x_k_list = [x] #x is x_0
    perms = []
    for i in range(100):
        #At start: Current x_k is the last item in x_k_list and P_k is the last item in perms
        perms.append(isotone_perm(x_k_list[-1])) #append P_k+1
        x_k_list.append(next_xk(x_k_list[-1])) #append x_k+1
    perms_array = np.vstack(perms)
    return perms_array



#Finds the permutation that when applied to x, makes x isotone (where applying is the operation x -> xP)
#Requires x to be nonnegative
#Equivalent to finding P_k+1 given x_k
def isotone_perm(x):
    x_copy = x.copy()
    perm = np.zeros((len(x)))
    for i in range(len(x)): #repeats len(x) times
        max = np.argmax(x_copy)
        perm[len(x) - i - 1] = max
        x_copy[max] = -1 # sets to value out of domain
        #print(str(max) + "  " + str(x) + "  " + str(perm))
    return perm
    

def is_isotone(x):
    prev = 0
    for curr in range(1, len(x)):
        if x[curr] < x[prev]:
            return False
        else:
            prev = curr
    return True

#Returns x, permuted by perm
def permute(x, perm):
    new_x = np.zeros((len(x)))
    for i in range(len(x)):
        new_x[i] = x[perm[i]]
    return new_x

#Returns x_k+1 given x_k
#Uses the matrix ideas in the proof of Proposition 2.8
def next_xk(xk):
    P_k1 = isotone_perm(xk) #P_k+1
    M_P_k1 = summation_matrix(P_k1) # M(P_k+1)
    #x_k = M(P_k+1) @ x_k+1
    x_k1 = np.linalg.inv(M_P_k1) @ xk
    #print(str(M_P_k1) + "  " + str(x_k1))
    return x_k1

#This function is a bit weird bc floating-point arithmetic determines how accurately we can find the depth
#def depth(x)

#line = pv.Line((0,0,0), (1,2,3))
#mesh = pv.PolyData(point)
#mesh.plot(point_size=10, style='points', color='red')

def many_tops(pl):
    points = []

    #perm_init = [0,1]
    perm_list = [[0,1], [1,0]]
    base = 2
    tick = 0 ##TODO replace tick with the i index in the loop
    block_length = 13 #Only generates periodic sequences with period 13 (no less)
    for i in range(base**block_length):
        periodic_block = []
        #for i in range(10):
            #periodic_block.append(random.permutation(perm_init))
        
        base_tick = to_base(tick, 2) #type str
        while len(base_tick) < block_length:
            base_tick = "0" + base_tick
        #print(base_tick)
        for digit in base_tick:
            periodic_block.append(perm_list[int(digit)])
        tick = tick + 1

        central_point = np.transpose(normalize_columns(generate_limcone(periodic_block, repeating=True)))[0]
        #print(periodic_block)
        print(central_point)
        if is_central(central_point):
            top = minimal_top(central_point.tolist())
            print(top)
            s = sum(top)
            top[0] = top[0] / s
            top[1] = top[1] / s
            top[2] = top[2] / s
            #pl.add_mesh(pv.Point((0,0,0), top), line_width=5)
            points.append(top)
        else:
            print("not central, tick = " + bin(tick-1)) #if not central, don't plot
    pl.add_mesh(pv.PolyData(points), color='blue')

        #print(periodic_block)
        #print(top)

def many_limcones(pl):
    points = []
    #perm_list = [[0,1,2], [0,2,1], [1,0,2], [1,2,0], [2,0,1], [2,1,0]]
    #perm_list = [[0,2,1], [2,0,1]]
    perm_list = [[0,1,2], [1,0,2]]
    base = 2
    tick = 0
    block_length = 13
    for i in range(base**block_length):
        periodic_block = []

        base_tick = to_base(tick, 2) #type str
        while len(base_tick) < block_length:
            base_tick = "0" + base_tick
        #print(base_tick)
        for digit in base_tick:
            periodic_block.append(perm_list[int(digit)])
        tick = tick + 1

        #This is just any arbitrary limcone--it'd be good to restrict to only the rank 2 limcones or the r2 limcones with a corner vertex, to compare to the topped pts
        limcone = normalize_columns(generate_limcone(periodic_block, repeating=True))
        #print(limcone)
        three_points = np.transpose(limcone)
        #print(three_points)
        points.append(three_points[0])#; points.append(three_points[1]); points.append(three_points[2])
        #limcone_mesh = pv.UnstructuredGrid([3, *list(range(3))], [pv.CellType.TRIANGLE], three_points)
        #pl.add_mesh(limcone_mesh)
    pl.add_mesh(pv.PolyData(points), color='red')


pl = pv.Plotter(shape=(1,2))

pl.subplot(0,0)
pl.add_mesh(pv.Line((0,0,0), (0,0,5)), line_width=3, color='black')
pl.add_mesh(pv.Line((0,0,0), (0,5,0)), line_width=3, color='black')
pl.add_mesh(pv.Line((0,0,0), (5,0,0)), line_width=3, color='black')
triangle = pv.UnstructuredGrid([3, *list(range(3))], [pv.CellType.TRIANGLE], [[1,0,0], [0,1,0], [0,0,1]])
pl.add_mesh(triangle)
pl.camera.position = (5,5,5)
#pl.camera.SetParallelProjection(True)

pl.subplot(0,1)
pl.add_mesh(pv.Line((0,0,0), (0,0,5)), line_width=3, color='black')
pl.add_mesh(pv.Line((0,0,0), (0,5,0)), line_width=3, color='black')
pl.add_mesh(pv.Line((0,0,0), (5,0,0)), line_width=3, color='black')
triangle = pv.UnstructuredGrid([3, *list(range(3))], [pv.CellType.TRIANGLE], [[1,0,0], [0,1,0], [0,0,1]])
pl.add_mesh(triangle)
pl.camera.position = (5,5,5)
#pl.camera.SetParallelProjection(True)

pl.subplot(0,0)
many_tops(pl)
pl.subplot(0,1)
many_limcones(pl)
pl.show()

x = [1, (1+math.sqrt(5))/2]
print([1, (1+math.sqrt(5))/2])
print(minimal_top([1, (1+math.sqrt(5))/2]))

#sum = central_sum([0.15032742, 0.18997817])
#print(sum)

#limcone = generate_limcone([[0,1,2],[1,0,2], [1,0,2],[1,0,2]], repeating=True)
#print(normalize_columns(limcone))

#plan for tomorrow:
#Write find_perm_seq routine
#Work on geometric visualization of the process
#Perhaps it would be interesting to graph the limcones generated by various periodic permutation sequences (say all combinations under a certain length)
#and see how they are laid out

#print(find_perm_seq(vec))

#print(permutation_matrix([1,2,0]))

#If centrality is a property of a ray, the length of the topping limcone shouldn't matter

#I think each j-topping corresponds to a different initial vertex for each j--if we top onto the nth coord, the limcones are rank-2 with a vertex at e_n

#Plan for tomorrow:
#Keep working on geometric visualization
#Try to figure out why red and blue don't match exactly

#Can a non minimal topping be central? Like on the line between (0,0,1) and (1,t,t^3), are there any central pts besides (1,t,t^3)
#If a periodic perm seq generates a limcone of rank greater than 1, are all vectors in that limcone centraL?
#Are there limcones with no rational vertices? Check Raney's notes for this

#Things to do:
#Understand proofs (specifically UMTC face proof)
#Write up outline of overall theory and construction
#Derive 3d/2d mapping and 4d/3d mapping
#Write up list of known facts/theorems
#Try to figure out if there's a connection between periodicity/nonconstancy and higher rank limcones
#Figure out/write code for propagating a point through depth (I think the theory for this is more grounded as of now)